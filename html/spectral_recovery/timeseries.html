<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>spectral_recovery.timeseries API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>spectral_recovery.timeseries</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import rioxarray

import xarray as xr
import geopandas as gpd
import pandas as pd
import numpy as np

from enum import Enum, auto
from typing import Union, Tuple
from datetime import datetime
from shapely.geometry import box
from spectral_recovery.indices import indices_map
from spectral_recovery.enums import Index, BandCommon

DATETIME_FREQ = &#34;YS&#34;
REQ_DIMS = [&#34;band&#34;, &#34;time&#34;, &#34;y&#34;, &#34;x&#34;]


def _stack_from_user_input(timeseries_dict, mask, timeseries_range=None):
    &#34;&#34;&#34;Stack a dictionary of rasters into a 4D DataArray.

    Dimensions of output DataArray will be (band, time, y, x) and the
    time dimension will contain np.datetime64 coordinates with datetime
    frequency set to `DATETIME_FREQ`.

    Parameters
    ----------
    timeseries_dict : Dict of str or DataArray
        Dict of paths to rasters or DataArrays to stack.
    mask : DataArray
        Mask to apply to stacked DataArrays.
    timeseries_range : list of int, optional
        The year range for the timeseries data.

    Returns
    -------
    DataArray :
        A 4D DataArray containing all rasters passed in
        `timeseries_dict` and optionally masked.

    &#34;&#34;&#34;
    if all([isinstance(data, str) for data in timeseries_dict.values()]):
        # Need to read in data
        for name, file in timeseries_dict.items():
            with rioxarray.open_rasterio(file, chunks=&#34;auto&#34;) as data:
                timeseries_dict[name] = data

    if all(
        [
            (isinstance(key, BandCommon) or isinstance(key, Index))
            for key in timeseries_dict.keys()
        ]
    ):
        for key, data in timeseries_dict.items():
            timeseries_dict[key] = data.rename({&#34;band&#34;: &#34;time&#34;})
        stacked_data = _stack_bands(
            timeseries_dict.values(), timeseries_dict.keys(), dim_name=&#34;band&#34;
        )
    elif all([isinstance(key, np.datetime64) for key in timeseries_dict.keys()]):
        stacked_data = _stack_bands(
            timeseries_dict.values(), timeseries_dict.keys(), dim_name=&#34;time&#34;
        )
    # TODO: catch missing dimension error here
    stacked_data = stacked_data.transpose(*REQ_DIMS)
    stacked_data = stacked_data.sortby(&#34;time&#34;)

    if timeseries_range is not None:
        stacked_data = stacked_data.assign_coords(
            time=(pd.date_range(*timeseries_range, freq=DATETIME_FREQ))
        )
    if not all(
        [isinstance(index, np.datetime64) for index in stacked_data.coords[&#34;time&#34;].data]
    ):
        raise ValueError(
            &#34;Time dimension not initialized as np.datetime64. If rasters passed&#34;
            &#34; per-band please ensure the `time_series` range parameter is set.&#34;
            &#34; Otherwise... something&#39;s gone wrong.&#34;
        ) from None
    if mask:
        masked_data = _mask_stack(stacked_data, mask)
        return masked_data
    else:
        return stacked_data


def _stack_bands(bands, names, dim_name):
    &#34;&#34;&#34;Stack 3D image stacks to create 4D image stack&#34;&#34;&#34;
    # TODO: handle band dimension/coordinate errors
    stacked_bands = xr.concat(bands, dim=pd.Index(names, name=dim_name))
    return stacked_bands


def _mask_stack(stack: xr.DataArray, mask: xr.DataArray, fill=np.nan):
    &#34;&#34;&#34;Mask a ND stack with 2D mask&#34;&#34;&#34;
    # TODO: should this allow more than 2D mask?
    if len(mask.dims) != 2:
        raise ValueError(f&#34;Mask must be 2D but {len(mask.dims)}D mask provided.&#34;)
    masked_stack = stack.where(mask, fill)
    return masked_stack


def datetime_to_index(
    value: Union[datetime, Tuple[datetime]], return_list: bool = False
) -&gt; pd.DatetimeIndex:
    &#34;&#34;&#34;Convert datetime or range of datetimes into pd.DatetimeIndex

    For ease of indexing through a DataArray object
    &#34;&#34;&#34;
    if (isinstance(value, tuple) or isinstance(value, list)) and len(value) == 2:
        dt_range = pd.date_range(*value, freq=DATETIME_FREQ)
    else:
        try:
            if len(value) &gt; 2:
                raise ValueError(
                    &#34;Passed value={value} but `datetime` must be a single Timestamp or an iterable with exactly two Timestamps.&#34;
                )
            dt_range = pd.date_range(start=value[0], end=value[0], freq=DATETIME_FREQ)
        except TypeError:
            dt_range = pd.date_range(start=value, end=value, freq=DATETIME_FREQ)
    if not return_list:
        return dt_range
    return dt_range.to_list()


# TODO: Generelize this to &#34;timeseries accessor&#34; or something similar
@xr.register_dataarray_accessor(&#34;yearcomp&#34;)
class YearlyCompositeAccessor:
    &#34;&#34;&#34;A DataArray accessor for annual composite operations.

    For methods related to yearly composite timeseries as well as
    general image stack operations.

    See &#34;Extending xarray using accessors&#34; for more information:
    https://docs.xarray.dev/en/stable/internals/extending-xarray.html

    &#34;&#34;&#34;

    def __init__(self, xarray_obj):
        self._obj = xarray_obj
        self._valid = None

    @property
    def valid(self):
        &#34;&#34;&#34;Return flag for whether DataArray is validy yearly comppsite.

        Checks whether the object has the required dimension labels (as
        defined by/for project) and valid coordinate values. Will
        massage object inplace where possible to try to make valid.

        &#34;&#34;&#34;
        if self._valid is None:
            if not set(self._obj.dims) == set(REQ_DIMS):
                self._valid = False

            # TODO: check for valid band coordinate names (`indices` needs
            # to be able to recognize them)
            # TODO: check that datetime frequency matches DATETIME_FREQ
            self._obj = self._obj.sortby(&#34;time&#34;)
            years = self._obj.time.dt.year.data

            if not np.all((years == list(range(min(years), max(years) + 1)))):
                self._valid = False
            self._valid = True
        return self._valid

    def contains_spatial(self, polygons: gpd.GeoDataFrame) -&gt; bool:
        &#34;&#34;&#34;Check if stack contains polygons.&#34;&#34;&#34;
        # NOTE: if this changes to looking at individual polygons
        # rather than the bbox of all polygons, consider this algo:
        # https://stackoverflow.com/questions/14697442/
        print(polygons)
        ext = box(*self._obj.rio.bounds())
        poly_ext = box(*polygons.total_bounds)
        if not ext.contains(poly_ext):
            return False
        return True

    def contains_temporal(self, years: datetime) -&gt; bool:
        &#34;&#34;&#34;Check if stack contains year/year range.&#34;&#34;&#34;
        required_years = datetime_to_index(years, return_list=True)
        for year in required_years:
            if not (pd.to_datetime(str(year)) in self._obj.coords[&#34;time&#34;].values):
                return False
        return True

    def indices(self, indices_list) -&gt; xr.DataArray:
        &#34;&#34;&#34;Compute indices

        Parameters
        ----------
        indices_list : list of str
            The list of indices to compute/produce.

        Returns
        --------
        xr.DataArray
            A 4D (band, time, y, x) DataArray with indices
            stacked inside the band dimension.
        &#34;&#34;&#34;
        indices_dict = {}
        for indice_input in indices_list:
            indice = Index(indice_input)
            indices_dict[indice] = indices_map[indice](self._obj)
        return _stack_bands(indices_dict.values(), indices_dict.keys(), dim_name=&#34;band&#34;)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="spectral_recovery.timeseries.datetime_to_index"><code class="name flex">
<span>def <span class="ident">datetime_to_index</span></span>(<span>value: Union[datetime.datetime, Tuple[datetime.datetime]], return_list: bool = False) ‑> pandas.core.indexes.datetimes.DatetimeIndex</span>
</code></dt>
<dd>
<div class="desc"><p>Convert datetime or range of datetimes into pd.DatetimeIndex</p>
<p>For ease of indexing through a DataArray object</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def datetime_to_index(
    value: Union[datetime, Tuple[datetime]], return_list: bool = False
) -&gt; pd.DatetimeIndex:
    &#34;&#34;&#34;Convert datetime or range of datetimes into pd.DatetimeIndex

    For ease of indexing through a DataArray object
    &#34;&#34;&#34;
    if (isinstance(value, tuple) or isinstance(value, list)) and len(value) == 2:
        dt_range = pd.date_range(*value, freq=DATETIME_FREQ)
    else:
        try:
            if len(value) &gt; 2:
                raise ValueError(
                    &#34;Passed value={value} but `datetime` must be a single Timestamp or an iterable with exactly two Timestamps.&#34;
                )
            dt_range = pd.date_range(start=value[0], end=value[0], freq=DATETIME_FREQ)
        except TypeError:
            dt_range = pd.date_range(start=value, end=value, freq=DATETIME_FREQ)
    if not return_list:
        return dt_range
    return dt_range.to_list()</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="spectral_recovery.timeseries.YearlyCompositeAccessor"><code class="flex name class">
<span>class <span class="ident">YearlyCompositeAccessor</span></span>
<span>(</span><span>xarray_obj)</span>
</code></dt>
<dd>
<div class="desc"><p>A DataArray accessor for annual composite operations.</p>
<p>For methods related to yearly composite timeseries as well as
general image stack operations.</p>
<p>See "Extending xarray using accessors" for more information:
<a href="https://docs.xarray.dev/en/stable/internals/extending-xarray.html">https://docs.xarray.dev/en/stable/internals/extending-xarray.html</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@xr.register_dataarray_accessor(&#34;yearcomp&#34;)
class YearlyCompositeAccessor:
    &#34;&#34;&#34;A DataArray accessor for annual composite operations.

    For methods related to yearly composite timeseries as well as
    general image stack operations.

    See &#34;Extending xarray using accessors&#34; for more information:
    https://docs.xarray.dev/en/stable/internals/extending-xarray.html

    &#34;&#34;&#34;

    def __init__(self, xarray_obj):
        self._obj = xarray_obj
        self._valid = None

    @property
    def valid(self):
        &#34;&#34;&#34;Return flag for whether DataArray is validy yearly comppsite.

        Checks whether the object has the required dimension labels (as
        defined by/for project) and valid coordinate values. Will
        massage object inplace where possible to try to make valid.

        &#34;&#34;&#34;
        if self._valid is None:
            if not set(self._obj.dims) == set(REQ_DIMS):
                self._valid = False

            # TODO: check for valid band coordinate names (`indices` needs
            # to be able to recognize them)
            # TODO: check that datetime frequency matches DATETIME_FREQ
            self._obj = self._obj.sortby(&#34;time&#34;)
            years = self._obj.time.dt.year.data

            if not np.all((years == list(range(min(years), max(years) + 1)))):
                self._valid = False
            self._valid = True
        return self._valid

    def contains_spatial(self, polygons: gpd.GeoDataFrame) -&gt; bool:
        &#34;&#34;&#34;Check if stack contains polygons.&#34;&#34;&#34;
        # NOTE: if this changes to looking at individual polygons
        # rather than the bbox of all polygons, consider this algo:
        # https://stackoverflow.com/questions/14697442/
        print(polygons)
        ext = box(*self._obj.rio.bounds())
        poly_ext = box(*polygons.total_bounds)
        if not ext.contains(poly_ext):
            return False
        return True

    def contains_temporal(self, years: datetime) -&gt; bool:
        &#34;&#34;&#34;Check if stack contains year/year range.&#34;&#34;&#34;
        required_years = datetime_to_index(years, return_list=True)
        for year in required_years:
            if not (pd.to_datetime(str(year)) in self._obj.coords[&#34;time&#34;].values):
                return False
        return True

    def indices(self, indices_list) -&gt; xr.DataArray:
        &#34;&#34;&#34;Compute indices

        Parameters
        ----------
        indices_list : list of str
            The list of indices to compute/produce.

        Returns
        --------
        xr.DataArray
            A 4D (band, time, y, x) DataArray with indices
            stacked inside the band dimension.
        &#34;&#34;&#34;
        indices_dict = {}
        for indice_input in indices_list:
            indice = Index(indice_input)
            indices_dict[indice] = indices_map[indice](self._obj)
        return _stack_bands(indices_dict.values(), indices_dict.keys(), dim_name=&#34;band&#34;)</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="spectral_recovery.timeseries.YearlyCompositeAccessor.valid"><code class="name">var <span class="ident">valid</span></code></dt>
<dd>
<div class="desc"><p>Return flag for whether DataArray is validy yearly comppsite.</p>
<p>Checks whether the object has the required dimension labels (as
defined by/for project) and valid coordinate values. Will
massage object inplace where possible to try to make valid.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def valid(self):
    &#34;&#34;&#34;Return flag for whether DataArray is validy yearly comppsite.

    Checks whether the object has the required dimension labels (as
    defined by/for project) and valid coordinate values. Will
    massage object inplace where possible to try to make valid.

    &#34;&#34;&#34;
    if self._valid is None:
        if not set(self._obj.dims) == set(REQ_DIMS):
            self._valid = False

        # TODO: check for valid band coordinate names (`indices` needs
        # to be able to recognize them)
        # TODO: check that datetime frequency matches DATETIME_FREQ
        self._obj = self._obj.sortby(&#34;time&#34;)
        years = self._obj.time.dt.year.data

        if not np.all((years == list(range(min(years), max(years) + 1)))):
            self._valid = False
        self._valid = True
    return self._valid</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="spectral_recovery.timeseries.YearlyCompositeAccessor.contains_spatial"><code class="name flex">
<span>def <span class="ident">contains_spatial</span></span>(<span>self, polygons: geopandas.geodataframe.GeoDataFrame) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Check if stack contains polygons.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def contains_spatial(self, polygons: gpd.GeoDataFrame) -&gt; bool:
    &#34;&#34;&#34;Check if stack contains polygons.&#34;&#34;&#34;
    # NOTE: if this changes to looking at individual polygons
    # rather than the bbox of all polygons, consider this algo:
    # https://stackoverflow.com/questions/14697442/
    print(polygons)
    ext = box(*self._obj.rio.bounds())
    poly_ext = box(*polygons.total_bounds)
    if not ext.contains(poly_ext):
        return False
    return True</code></pre>
</details>
</dd>
<dt id="spectral_recovery.timeseries.YearlyCompositeAccessor.contains_temporal"><code class="name flex">
<span>def <span class="ident">contains_temporal</span></span>(<span>self, years: datetime.datetime) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Check if stack contains year/year range.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def contains_temporal(self, years: datetime) -&gt; bool:
    &#34;&#34;&#34;Check if stack contains year/year range.&#34;&#34;&#34;
    required_years = datetime_to_index(years, return_list=True)
    for year in required_years:
        if not (pd.to_datetime(str(year)) in self._obj.coords[&#34;time&#34;].values):
            return False
    return True</code></pre>
</details>
</dd>
<dt id="spectral_recovery.timeseries.YearlyCompositeAccessor.indices"><code class="name flex">
<span>def <span class="ident">indices</span></span>(<span>self, indices_list) ‑> xarray.core.dataarray.DataArray</span>
</code></dt>
<dd>
<div class="desc"><p>Compute indices</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>indices_list</code></strong> :&ensp;<code>list</code> of <code>str</code></dt>
<dd>The list of indices to compute/produce.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>xr.DataArray</code></dt>
<dd>A 4D (band, time, y, x) DataArray with indices
stacked inside the band dimension.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def indices(self, indices_list) -&gt; xr.DataArray:
    &#34;&#34;&#34;Compute indices

    Parameters
    ----------
    indices_list : list of str
        The list of indices to compute/produce.

    Returns
    --------
    xr.DataArray
        A 4D (band, time, y, x) DataArray with indices
        stacked inside the band dimension.
    &#34;&#34;&#34;
    indices_dict = {}
    for indice_input in indices_list:
        indice = Index(indice_input)
        indices_dict[indice] = indices_map[indice](self._obj)
    return _stack_bands(indices_dict.values(), indices_dict.keys(), dim_name=&#34;band&#34;)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="spectral_recovery" href="index.html">spectral_recovery</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="spectral_recovery.timeseries.datetime_to_index" href="#spectral_recovery.timeseries.datetime_to_index">datetime_to_index</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="spectral_recovery.timeseries.YearlyCompositeAccessor" href="#spectral_recovery.timeseries.YearlyCompositeAccessor">YearlyCompositeAccessor</a></code></h4>
<ul class="">
<li><code><a title="spectral_recovery.timeseries.YearlyCompositeAccessor.contains_spatial" href="#spectral_recovery.timeseries.YearlyCompositeAccessor.contains_spatial">contains_spatial</a></code></li>
<li><code><a title="spectral_recovery.timeseries.YearlyCompositeAccessor.contains_temporal" href="#spectral_recovery.timeseries.YearlyCompositeAccessor.contains_temporal">contains_temporal</a></code></li>
<li><code><a title="spectral_recovery.timeseries.YearlyCompositeAccessor.indices" href="#spectral_recovery.timeseries.YearlyCompositeAccessor.indices">indices</a></code></li>
<li><code><a title="spectral_recovery.timeseries.YearlyCompositeAccessor.valid" href="#spectral_recovery.timeseries.YearlyCompositeAccessor.valid">valid</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>